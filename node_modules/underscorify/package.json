{
  "name": "underscorify",
  "description": "an itty bitty curry utility",
  "version": "1.0.0",
  "author": {
    "name": "Isaac Z. Schlueter",
    "email": "i@izs.me",
    "url": "http://blog.izs.me/"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/isaacs/_ify.git"
  },
  "main": "./_ify.js",
  "readme": "\n# _ify – an itty bitty curry utility\n\ntransform the function such that you can fix any of the arguments,\npassing `_` as a \"placeholder\".\n\nIf any places are not filled, it returns a \"callback\" instead of executing the function.\nIt also returns a callback the first time, even if you didn't give it any holes.\n(But in that case, it's not awaiting anything so just () will execute it.)\n\nAn underbar `_` is a \"hole\".  It keeps trying to fill the holes until there are none left.\nOnce you've \\_ified the function, it can receive holes, and will handle them\nappropriately.  When all the holes are filled, it executes the function.\n\nA triple-underbar \\_\\_\\_ is a bigger hole.  The remaining arguments all fall into it.\n\nEnough talk. Example time!\n\n\tfunction timesSquared (x, y) { return x * y * y }\n\tvar times2Squared = _(timesSquared)( _, 2 ) or timesSquared._(_, 2);\n\ttimes2Squared(3) = timesSquared(3, 2) = 12\n\nIn the \\_ified function, if all the spaces are not filled in, it returns\nanother \\_ified function with the remaining spaces blank.\n\nMore examples:\n\n\tf._(_,_) ==> curryable function requiring 2 args\n\tf._(_,_)(x) ==> f._(x,_) ==> function curried to 1 arg, requiring one more for execution\n\tf._(_)._(_) ==> passing _ leaves the hole open, so this is the same as just f._(_)\n\nin general, doing .\\_() just needs to happen once.\tdoing it a second time is unnecessary.\n\n\tf._(_)(_,_) ==> passes _ as the first arg, then the second, so it's the same as f._(_,_)\n\tf._(_,_)(_,_,_) ==> f._(_,_,_)\n\tf._(_,_,_)(1,_,2) ==> f._(1,_,2) still awaiting second argument.\n\tf._(_,_,_)(1,_,2)(3) ==> f._(1,_,2)(3) ==> f(1,3,2)\n\tf._(_,1)(2,3,4) ==> f(2,1,3,4) additional args are appended to list.\n\tf._(___,_,1) ==> additional args go in the ___ member, if one is provided.\n\tf._(___,1)(___,2)(3,4,5) ==> f._(___,1,2)(3,4,5) a big hole fills a big hole\n\tf._(___,_,1)(___,2) ==> f._(___,2,1) right-hand curried with 2,1\n\tf._(___,_,1)(___,2)(3,4,5) ==> f._(___,2,1)(3,4,5) ==> f(3,4,5,2,1)\n\tf._(___,1,2) is just like Y.rbind(f, null, 1, 2)\n\tf._(1,___,_,2)(___,3)(4,5) ==> f._(1,___,3,2)(4,5) ==> f(1,4,5,3,2)\n\nextra args will go into the first \\_\\_\\_ that is found. so, if there are two, you have to call it twice.\n\n\tf._(___,___)(1,2)(3,4,5) ==> f._(1,2,___)(3,4,5) ==> f(1,2,3,4,5)\n\nYou can use \\_\\_\\_ to dig a hole deeper.\n\n\tf._(_,1)(___,2)(3,4,5) ==> f._(___,1,2)(3,4,5) ==> f(3,4,5,1,2)\n\tf._(_)(___,1)(2,3,4) ==> f._(___,1)(2,3,4) ==> f(2,3,4,1)\n\nfurthermore...\n\n\t_(f) === f._\n\t_(f)(1,_) === f._(1,_)\n\t// etc.\n\nBut wait! There's more!\n\n\tf._(1,2,3) ==> ?\n\nNo holes, so what happens?\nIt doesn't quite make sense to have it just do the same thing as `f(1,2,3)`\nSo, instead, it returns a callback that can take \\_ arguments.\n\nSo:\n\n\tf._(1,2,3)(a,_,c)(b) === f(1,2,3,a,b,c)\n\tsetTimeout(foo._(bar)),0) === setTimeout(function () { foo(bar) }, 0)\n\tf._()(1,_,2,___)(3)(4,5,6) === f._(1,3,2,___)(4,5,6) === f(1,3,2,4,5,6)\n\tf._(1,2)(___,3,4)(5,6) === f._(1,2,___,3,4)(5,6) === f(1,2,5,6,3,4)\n\nSo how do I fix scope, you ask?\n\nWith the \\_\\_\\_!\n\nIt works just like \\_, but the first argument is used to set the scope.\n\nso,\n\n\tf.___(obj, 1, 2) ==> function () { return f.call(obj, 1, 2) }\n\nThis doesn't execute immediately, because remember there's always at least one\nlevel of indirection (otherwise it's pointless, and you can always add ()\nif you really want it to execute right away.)\n\nThis one executes right away, because there's already a single redirection.\n\n\t___(f, obj)(1, 2) ==> f.___(obj)(1,2) ==> (function () { return f.call(obj, 1, 2) } )()\n\nAnd of course, this works, too:\n\n\tf.___(obj, 1)(_, 2)(3) ==> f.call(obj, 1, 3, 2)\n\n## But I don't like \\_ and \\_\\_\\_ (or I'm already using them for something else)\n\nThat's fine.  You can use the \\_.load and \\_.unload functions to swap out new symbols.  Maybe you like\nto call them $ and $$$ instead of \\_ and \\_\\_\\_.  Great.  Just do this:\n\n\t_.unload.load({_:\"$\", ___:\"$$$\"})\n\nAny string is fine, but some will lead to uglier code, of course.  This is not pretty:\n\n\tmyFunction[\"BLΩRHEHA(F#HA(HFZZXNBFZ..#H(A\"](window[\"BLΩRHEHA(F#HA(HFZZXNBFZ..#H(A\"], 2)\n\n`ƒ` and `µ` are valid and pretty identifiers and reasonably pretty and easy to type (on a mac).\nYou could even remove all global references to \\_ and \\_\\_\\_, and just use them as private vars.\nThe \\_.unload() function returns an object with references to \\_ and \\_\\_\\_, so you can\ndo whatever you want with that. For instance:\n\n\tvar myUnderscore = _.unload();\n\nand then \\_ is at `myUnderscore._` and \\_\\_\\_ is on `myUnderscore.___`, and you can use\nthem just as if they were the globals.  For example:\n\n\t_.unload.load({ _ : \"$\", ___ : \"derp\" }); // unload the globals, and load the new ones.\n\t$(f)(1,2,3)() ==> f(1,2,3)\n\t$(f)(1,$,2)(3) ==> f(1,3,2)\n\tf.$(1,$,2)(3,$)($,4)(5) ==> f.$(1,3,2,$)($,4)(5) ==> f.$(1,3,2,$,4)(5) ==> f(1,3,2,5,4)\n\tf.derp(obj, $, 1)(2) ==> f.call(obj, 2, 1)\n\tf.$(derp, 1, 2)(4,5,6) ==> f(4,5,6,1,2)\n\t\n\t// of course, this means you can't do f._() or f.___()\n\tvar y = _.unload();\n\ty._(f)(1,2,3)() ==> f(1,2,3)\n\ty.___(f, obj)(1,2,3)() ==> f.call(obj, 1,2,3)\n\ty._(f, y.___, 1, 2, y._)(3,4,5)(6) ==> f(3,4,5,1,2,6)\n\nBasically, you'd just be changing the symbol that's used in all the examples below.  From now on, I'm going to use `_` and `___`, because think those are prettiest.\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/isaacs/_ify/issues"
  },
  "homepage": "https://github.com/isaacs/_ify",
  "_id": "underscorify@1.0.0",
  "_from": "underscorify@>=1.0.0 <2.0.0"
}
